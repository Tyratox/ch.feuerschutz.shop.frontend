# Exposes a URL that specifies the behaviour of this scalar.
directive @specifiedBy(
  # The URL that specifies the behaviour of this scalar.
  url: String!
) on SCALAR

union ActiveOrderResult = Order | NoActiveOrderError

union AddPaymentToOrderResult =
    Order
  | OrderPaymentStateError
  | IneligiblePaymentMethodError
  | PaymentFailedError
  | PaymentDeclinedError
  | OrderStateTransitionError
  | NoActiveOrderError

type Address implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  fullName: String
  company: String
  streetLine1: String!
  streetLine2: String
  city: String
  province: String
  postalCode: String
  country: Country!
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: JSON
}

type Adjustment {
  adjustmentSource: String!
  type: AdjustmentType!
  description: String!
  amount: Int!
}

enum AdjustmentType {
  PROMOTION
  DISTRIBUTED_ORDER_PROMOTION
}

# Retured when attemting to set the Customer for an Order when already logged in.
type AlreadyLoggedInError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

union ApplyCouponCodeResult =
    Order
  | CouponCodeExpiredError
  | CouponCodeInvalidError
  | CouponCodeLimitError

type Asset implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  type: AssetType!
  fileSize: Int!
  mimeType: String!
  width: Int!
  height: Int!
  source: String!
  preview: String!
  focalPoint: Coordinate
  customFields: JSON
}

type AssetList implements PaginatedList {
  items: [Asset!]!
  totalItems: Int!
}

enum AssetType {
  IMAGE
  VIDEO
  BINARY
}

input AuthenticationInput {
  native: NativeAuthInput
  legacy: LegacyAuthInput
}

type AuthenticationMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  strategy: String!
}

union AuthenticationResult =
    CurrentUser
  | InvalidCredentialsError
  | NotVerifiedError

type BooleanCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
}

input BooleanOperators {
  eq: Boolean
}

type BulkDiscount {
  productVariant: ProductVariant!
  quantity: Int!
  price: Int!
}

type Channel implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  token: String!
  defaultTaxZone: Zone
  defaultShippingZone: Zone
  defaultLanguageCode: LanguageCode!
  currencyCode: CurrencyCode!
  pricesIncludeTax: Boolean!
  customFields: JSON
}

type Collection implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode
  name: String!
  slug: String!
  breadcrumbs: [CollectionBreadcrumb!]!
  position: Int!
  description: String!
  featuredAsset: Asset
  assets: [Asset!]!
  parent: Collection
  children: [Collection!]
  filters: [ConfigurableOperation!]!
  translations: [CollectionTranslation!]!
  productVariants(options: ProductVariantListOptions): ProductVariantList!
  links: [CollectionLink!]!
  products: [Product!]!
  customFields: JSON
}

type CollectionBreadcrumb {
  id: ID!
  name: String!
  slug: String!
}

input CollectionFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  slug: StringOperators
  position: NumberOperators
  description: StringOperators
}

type CollectionLink {
  id: ID!
  collection: Collection!
  collectionId: ID!
  icon: CollectionLinkType!
  order: Int!
  name: String!
  url: String!
}

type CollectionLinkTranslation {
  id: ID!
  languageCode: LanguageCode!
  name: ID!
  url: String!
}

enum CollectionLinkType {
  PDF
  VIDEO
  LINK
}

type CollectionList implements PaginatedList {
  items: [Collection!]!
  totalItems: Int!
}

input CollectionListOptions {
  skip: Int
  take: Int
  sort: CollectionSortParameter
  filter: CollectionFilterParameter
}

input CollectionSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  slug: SortOrder
  position: SortOrder
  description: SortOrder
}

type CollectionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
}

type ConfigArg {
  name: String!
  value: String!
}

type ConfigArgDefinition {
  name: String!
  type: String!
  list: Boolean!
  required: Boolean!
  defaultValue: JSON
  label: String
  description: String
  ui: JSON
}

input ConfigArgInput {
  name: String!

  # A JSON stringified representation of the actual value
  value: String!
}

type ConfigurableOperation {
  code: String!
  args: [ConfigArg!]!
}

type ConfigurableOperationDefinition {
  code: String!
  args: [ConfigArgDefinition!]!
  description: String!
}

input ConfigurableOperationInput {
  code: String!
  arguments: [ConfigArgInput!]!
}

type Coordinate {
  x: Float!
  y: Float!
}

type Country implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  enabled: Boolean!
  translations: [CountryTranslation!]!
}

type CountryList implements PaginatedList {
  items: [Country!]!
  totalItems: Int!
}

type CountryTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

# Returned if the provided coupon code is invalid
type CouponCodeExpiredError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  couponCode: String!
}

# Returned if the provided coupon code is invalid
type CouponCodeInvalidError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  couponCode: String!
}

# Returned if the provided coupon code is invalid
type CouponCodeLimitError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  couponCode: String!
  limit: Int!
}

input CreateAddressInput {
  fullName: String
  company: String
  streetLine1: String!
  streetLine2: String
  city: String
  province: String
  postalCode: String
  countryCode: String!
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: JSON
}

input CreateCustomerInput {
  title: String
  firstName: String!
  lastName: String!
  phoneNumber: String
  emailAddress: String!
  customFields: JSON
}

# @description
# ISO 4217 currency code
#
# @docsCategory common
enum CurrencyCode {
  # United Arab Emirates dirham
  AED

  # Afghan afghani
  AFN

  # Albanian lek
  ALL

  # Armenian dram
  AMD

  # Netherlands Antillean guilder
  ANG

  # Angolan kwanza
  AOA

  # Argentine peso
  ARS

  # Australian dollar
  AUD

  # Aruban florin
  AWG

  # Azerbaijani manat
  AZN

  # Bosnia and Herzegovina convertible mark
  BAM

  # Barbados dollar
  BBD

  # Bangladeshi taka
  BDT

  # Bulgarian lev
  BGN

  # Bahraini dinar
  BHD

  # Burundian franc
  BIF

  # Bermudian dollar
  BMD

  # Brunei dollar
  BND

  # Boliviano
  BOB

  # Brazilian real
  BRL

  # Bahamian dollar
  BSD

  # Bhutanese ngultrum
  BTN

  # Botswana pula
  BWP

  # Belarusian ruble
  BYN

  # Belize dollar
  BZD

  # Canadian dollar
  CAD

  # Congolese franc
  CDF

  # Swiss franc
  CHF

  # Chilean peso
  CLP

  # Renminbi (Chinese) yuan
  CNY

  # Colombian peso
  COP

  # Costa Rican colon
  CRC

  # Cuban convertible peso
  CUC

  # Cuban peso
  CUP

  # Cape Verde escudo
  CVE

  # Czech koruna
  CZK

  # Djiboutian franc
  DJF

  # Danish krone
  DKK

  # Dominican peso
  DOP

  # Algerian dinar
  DZD

  # Egyptian pound
  EGP

  # Eritrean nakfa
  ERN

  # Ethiopian birr
  ETB

  # Euro
  EUR

  # Fiji dollar
  FJD

  # Falkland Islands pound
  FKP

  # Pound sterling
  GBP

  # Georgian lari
  GEL

  # Ghanaian cedi
  GHS

  # Gibraltar pound
  GIP

  # Gambian dalasi
  GMD

  # Guinean franc
  GNF

  # Guatemalan quetzal
  GTQ

  # Guyanese dollar
  GYD

  # Hong Kong dollar
  HKD

  # Honduran lempira
  HNL

  # Croatian kuna
  HRK

  # Haitian gourde
  HTG

  # Hungarian forint
  HUF

  # Indonesian rupiah
  IDR

  # Israeli new shekel
  ILS

  # Indian rupee
  INR

  # Iraqi dinar
  IQD

  # Iranian rial
  IRR

  # Icelandic króna
  ISK

  # Jamaican dollar
  JMD

  # Jordanian dinar
  JOD

  # Japanese yen
  JPY

  # Kenyan shilling
  KES

  # Kyrgyzstani som
  KGS

  # Cambodian riel
  KHR

  # Comoro franc
  KMF

  # North Korean won
  KPW

  # South Korean won
  KRW

  # Kuwaiti dinar
  KWD

  # Cayman Islands dollar
  KYD

  # Kazakhstani tenge
  KZT

  # Lao kip
  LAK

  # Lebanese pound
  LBP

  # Sri Lankan rupee
  LKR

  # Liberian dollar
  LRD

  # Lesotho loti
  LSL

  # Libyan dinar
  LYD

  # Moroccan dirham
  MAD

  # Moldovan leu
  MDL

  # Malagasy ariary
  MGA

  # Macedonian denar
  MKD

  # Myanmar kyat
  MMK

  # Mongolian tögrög
  MNT

  # Macanese pataca
  MOP

  # Mauritanian ouguiya
  MRU

  # Mauritian rupee
  MUR

  # Maldivian rufiyaa
  MVR

  # Malawian kwacha
  MWK

  # Mexican peso
  MXN

  # Malaysian ringgit
  MYR

  # Mozambican metical
  MZN

  # Namibian dollar
  NAD

  # Nigerian naira
  NGN

  # Nicaraguan córdoba
  NIO

  # Norwegian krone
  NOK

  # Nepalese rupee
  NPR

  # New Zealand dollar
  NZD

  # Omani rial
  OMR

  # Panamanian balboa
  PAB

  # Peruvian sol
  PEN

  # Papua New Guinean kina
  PGK

  # Philippine peso
  PHP

  # Pakistani rupee
  PKR

  # Polish złoty
  PLN

  # Paraguayan guaraní
  PYG

  # Qatari riyal
  QAR

  # Romanian leu
  RON

  # Serbian dinar
  RSD

  # Russian ruble
  RUB

  # Rwandan franc
  RWF

  # Saudi riyal
  SAR

  # Solomon Islands dollar
  SBD

  # Seychelles rupee
  SCR

  # Sudanese pound
  SDG

  # Swedish krona/kronor
  SEK

  # Singapore dollar
  SGD

  # Saint Helena pound
  SHP

  # Sierra Leonean leone
  SLL

  # Somali shilling
  SOS

  # Surinamese dollar
  SRD

  # South Sudanese pound
  SSP

  # São Tomé and Príncipe dobra
  STN

  # Salvadoran colón
  SVC

  # Syrian pound
  SYP

  # Swazi lilangeni
  SZL

  # Thai baht
  THB

  # Tajikistani somoni
  TJS

  # Turkmenistan manat
  TMT

  # Tunisian dinar
  TND

  # Tongan paʻanga
  TOP

  # Turkish lira
  TRY

  # Trinidad and Tobago dollar
  TTD

  # New Taiwan dollar
  TWD

  # Tanzanian shilling
  TZS

  # Ukrainian hryvnia
  UAH

  # Ugandan shilling
  UGX

  # United States dollar
  USD

  # Uruguayan peso
  UYU

  # Uzbekistan som
  UZS

  # Venezuelan bolívar soberano
  VES

  # Vietnamese đồng
  VND

  # Vanuatu vatu
  VUV

  # Samoan tala
  WST

  # CFA franc BEAC
  XAF

  # East Caribbean dollar
  XCD

  # CFA franc BCEAO
  XOF

  # CFP franc (franc Pacifique)
  XPF

  # Yemeni rial
  YER

  # South African rand
  ZAR

  # Zambian kwacha
  ZMW

  # Zimbabwean dollar
  ZWL
}

type CurrentUser {
  id: ID!
  identifier: String!
  channels: [CurrentUserChannel!]!
}

type CurrentUserChannel {
  id: ID!
  token: String!
  code: String!
  permissions: [Permission!]!
}

type Customer implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String
  firstName: String!
  lastName: String!
  phoneNumber: String
  emailAddress: String!
  addresses: [Address!]
  orders(options: OrderListOptions): OrderList!
  user: User
  resellerDiscounts: [ResellerDiscount!]!
  customFields: JSON
}

input CustomerFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  title: StringOperators
  firstName: StringOperators
  lastName: StringOperators
  phoneNumber: StringOperators
  emailAddress: StringOperators
}

type CustomerGroup implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  customers(options: CustomerListOptions): CustomerList!
}

type CustomerList implements PaginatedList {
  items: [Customer!]!
  totalItems: Int!
}

input CustomerListOptions {
  skip: Int
  take: Int
  sort: CustomerSortParameter
  filter: CustomerFilterParameter
}

input CustomerSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  title: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  phoneNumber: SortOrder
  emailAddress: SortOrder
}

interface CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
}

union CustomFieldConfig =
    StringCustomFieldConfig
  | LocaleStringCustomFieldConfig
  | IntCustomFieldConfig
  | FloatCustomFieldConfig
  | BooleanCustomFieldConfig
  | DateTimeCustomFieldConfig
  | RelationCustomFieldConfig

input DateOperators {
  eq: DateTime
  before: DateTime
  after: DateTime
  between: DateRange
}

input DateRange {
  start: DateTime!
  end: DateTime!
}

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
# `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
# 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

# Expects the same validation formats as the `<input type="datetime-local">` HTML element.
# See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local#Additional_attributes
type DateTimeCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  min: String
  max: String
  step: Int
}

type DeletionResponse {
  result: DeletionResult!
  message: String
}

enum DeletionResult {
  # The entity was successfully deleted
  DELETED

  # Deletion did not take place, reason given in message
  NOT_DELETED
}

# Retured when attemting to create a Customer with an email address already registered to an existing User.
type EmailAddressConflictError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

enum ErrorCode {
  UNKNOWN_ERROR
  NATIVE_AUTH_STRATEGY_ERROR
  INVALID_CREDENTIALS_ERROR
  ORDER_STATE_TRANSITION_ERROR
  EMAIL_ADDRESS_CONFLICT_ERROR
  ORDER_LIMIT_ERROR
  NEGATIVE_QUANTITY_ERROR
  INSUFFICIENT_STOCK_ERROR
  ORDER_MODIFICATION_ERROR
  INELIGIBLE_SHIPPING_METHOD_ERROR
  ORDER_PAYMENT_STATE_ERROR
  INELIGIBLE_PAYMENT_METHOD_ERROR
  PAYMENT_FAILED_ERROR
  PAYMENT_DECLINED_ERROR
  COUPON_CODE_INVALID_ERROR
  COUPON_CODE_EXPIRED_ERROR
  COUPON_CODE_LIMIT_ERROR
  ALREADY_LOGGED_IN_ERROR
  MISSING_PASSWORD_ERROR
  PASSWORD_ALREADY_SET_ERROR
  VERIFICATION_TOKEN_INVALID_ERROR
  VERIFICATION_TOKEN_EXPIRED_ERROR
  IDENTIFIER_CHANGE_TOKEN_INVALID_ERROR
  IDENTIFIER_CHANGE_TOKEN_EXPIRED_ERROR
  PASSWORD_RESET_TOKEN_INVALID_ERROR
  PASSWORD_RESET_TOKEN_EXPIRED_ERROR
  NOT_VERIFIED_ERROR
  NO_ACTIVE_ORDER_ERROR
}

interface ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

type Facet implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  code: String!
  values: [FacetValue!]!
  translations: [FacetTranslation!]!
  customFields: JSON
}

type FacetList implements PaginatedList {
  items: [Facet!]!
  totalItems: Int!
}

type FacetTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type FacetValue implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  facet: Facet!
  name: String!
  code: String!
  translations: [FacetValueTranslation!]!
  customFields: JSON
}

# Which FacetValues are present in the products returned
# by the search, and in what quantity.
type FacetValueResult {
  facetValue: FacetValue!
  count: Int!
}

type FacetValueTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type FloatCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  min: Float
  max: Float
  step: Float
}

type Fulfillment implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  orderItems: [OrderItem!]!
  state: String!
  method: String!
  trackingCode: String
  customFields: JSON
}

enum GlobalFlag {
  TRUE
  FALSE
  INHERIT
}

type HistoryEntry implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: HistoryEntryType!
  data: JSON!
}

input HistoryEntryFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  type: StringOperators
}

type HistoryEntryList implements PaginatedList {
  items: [HistoryEntry!]!
  totalItems: Int!
}

input HistoryEntryListOptions {
  skip: Int
  take: Int
  sort: HistoryEntrySortParameter
  filter: HistoryEntryFilterParameter
}

input HistoryEntrySortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

enum HistoryEntryType {
  CUSTOMER_REGISTERED
  CUSTOMER_VERIFIED
  CUSTOMER_DETAIL_UPDATED
  CUSTOMER_ADDED_TO_GROUP
  CUSTOMER_REMOVED_FROM_GROUP
  CUSTOMER_ADDRESS_CREATED
  CUSTOMER_ADDRESS_UPDATED
  CUSTOMER_ADDRESS_DELETED
  CUSTOMER_PASSWORD_UPDATED
  CUSTOMER_PASSWORD_RESET_REQUESTED
  CUSTOMER_PASSWORD_RESET_VERIFIED
  CUSTOMER_EMAIL_UPDATE_REQUESTED
  CUSTOMER_EMAIL_UPDATE_VERIFIED
  CUSTOMER_NOTE
  ORDER_STATE_TRANSITION
  ORDER_PAYMENT_TRANSITION
  ORDER_FULFILLMENT
  ORDER_CANCELLATION
  ORDER_REFUND_TRANSITION
  ORDER_FULFILLMENT_TRANSITION
  ORDER_NOTE
  ORDER_COUPON_APPLIED
  ORDER_COUPON_REMOVED
  ORDER_MODIFIED
}

# Retured if the token used to change a Customer's email address is valid, but has
# expired according to the `verificationTokenDuration` setting in the AuthOptions.
type IdentifierChangeTokenExpiredError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

# Retured if the token used to change a Customer's email address is either
# invalid or does not match any expected tokens.
type IdentifierChangeTokenInvalidError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

# Returned when attempting to add a Payment using a PaymentMethod for which the Order is not eligible.
type IneligiblePaymentMethodError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  eligibilityCheckerMessage: String
}

# Returned when attempting to set a ShippingMethod for which the Order is not eligible
type IneligibleShippingMethodError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

# Returned when attempting to add more items to the Order than are available
type InsufficientStockError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  quantityAvailable: Int!
  order: Order!
}

type IntCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  min: Int
  max: Int
  step: Int
}

# Returned if the user authentication credentials are not valid
type InvalidCredentialsError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  authenticationError: String!
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

# @description
# Languages in the form of a ISO 639-1 language code with optional
# region or script modifier (e.g. de_AT). The selection available is based
# on the [Unicode CLDR summary list](https://unicode-org.github.io/cldr-staging/charts/37/summary/root.html)
# and includes the major spoken languages of the world and any widely-used variants.
#
# @docsCategory common
enum LanguageCode {
  # Afrikaans
  af

  # Akan
  ak

  # Albanian
  sq

  # Amharic
  am

  # Arabic
  ar

  # Armenian
  hy

  # Assamese
  as

  # Azerbaijani
  az

  # Bambara
  bm

  # Bangla
  bn

  # Basque
  eu

  # Belarusian
  be

  # Bosnian
  bs

  # Breton
  br

  # Bulgarian
  bg

  # Burmese
  my

  # Catalan
  ca

  # Chechen
  ce

  # Chinese
  zh

  # Simplified Chinese
  zh_Hans

  # Traditional Chinese
  zh_Hant

  # Church Slavic
  cu

  # Cornish
  kw

  # Corsican
  co

  # Croatian
  hr

  # Czech
  cs

  # Danish
  da

  # Dutch
  nl

  # Flemish
  nl_BE

  # Dzongkha
  dz

  # English
  en

  # Australian English
  en_AU

  # Canadian English
  en_CA

  # British English
  en_GB

  # American English
  en_US

  # Esperanto
  eo

  # Estonian
  et

  # Ewe
  ee

  # Faroese
  fo

  # Finnish
  fi

  # French
  fr

  # Canadian French
  fr_CA

  # Swiss French
  fr_CH

  # Fulah
  ff

  # Galician
  gl

  # Ganda
  lg

  # Georgian
  ka

  # German
  de

  # Austrian German
  de_AT

  # Swiss High German
  de_CH

  # Greek
  el

  # Gujarati
  gu

  # Haitian Creole
  ht

  # Hausa
  ha

  # Hebrew
  he

  # Hindi
  hi

  # Hungarian
  hu

  # Icelandic
  is

  # Igbo
  ig

  # Indonesian
  id

  # Interlingua
  ia

  # Irish
  ga

  # Italian
  it

  # Japanese
  ja

  # Javanese
  jv

  # Kalaallisut
  kl

  # Kannada
  kn

  # Kashmiri
  ks

  # Kazakh
  kk

  # Khmer
  km

  # Kikuyu
  ki

  # Kinyarwanda
  rw

  # Korean
  ko

  # Kurdish
  ku

  # Kyrgyz
  ky

  # Lao
  lo

  # Latin
  la

  # Latvian
  lv

  # Lingala
  ln

  # Lithuanian
  lt

  # Luba-Katanga
  lu

  # Luxembourgish
  lb

  # Macedonian
  mk

  # Malagasy
  mg

  # Malay
  ms

  # Malayalam
  ml

  # Maltese
  mt

  # Manx
  gv

  # Maori
  mi

  # Marathi
  mr

  # Mongolian
  mn

  # Nepali
  ne

  # North Ndebele
  nd

  # Northern Sami
  se

  # Norwegian Bokmål
  nb

  # Norwegian Nynorsk
  nn

  # Nyanja
  ny

  # Odia
  or

  # Oromo
  om

  # Ossetic
  os

  # Pashto
  ps

  # Persian
  fa

  # Dari
  fa_AF

  # Polish
  pl

  # Portuguese
  pt

  # Brazilian Portuguese
  pt_BR

  # European Portuguese
  pt_PT

  # Punjabi
  pa

  # Quechua
  qu

  # Romanian
  ro

  # Moldavian
  ro_MD

  # Romansh
  rm

  # Rundi
  rn

  # Russian
  ru

  # Samoan
  sm

  # Sango
  sg

  # Sanskrit
  sa

  # Scottish Gaelic
  gd

  # Serbian
  sr

  # Shona
  sn

  # Sichuan Yi
  ii

  # Sindhi
  sd

  # Sinhala
  si

  # Slovak
  sk

  # Slovenian
  sl

  # Somali
  so

  # Southern Sotho
  st

  # Spanish
  es

  # European Spanish
  es_ES

  # Mexican Spanish
  es_MX

  # Sundanese
  su

  # Swahili
  sw

  # Congo Swahili
  sw_CD

  # Swedish
  sv

  # Tajik
  tg

  # Tamil
  ta

  # Tatar
  tt

  # Telugu
  te

  # Thai
  th

  # Tibetan
  bo

  # Tigrinya
  ti

  # Tongan
  to

  # Turkish
  tr

  # Turkmen
  tk

  # Ukrainian
  uk

  # Urdu
  ur

  # Uyghur
  ug

  # Uzbek
  uz

  # Vietnamese
  vi

  # Volapük
  vo

  # Welsh
  cy

  # Western Frisian
  fy

  # Wolof
  wo

  # Xhosa
  xh

  # Yiddish
  yi

  # Yoruba
  yo

  # Zulu
  zu
}

input LegacyAuthInput {
  email: String!
  password: String!
}

type LocaleStringCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  length: Int
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  pattern: String
}

type LocalizedString {
  languageCode: LanguageCode!
  value: String!
}

enum LogicalOperator {
  AND
  OR
}

# Retured when attemting to register or verify a customer account without a password, when one is required.
type MissingPasswordError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

type Mutation {
  # Adds an item to the order. If custom fields are defined on the OrderLine
  # entity, a third argument 'customFields' will be available.
  addItemToOrder(productVariantId: ID!, quantity: Int!): UpdateOrderItemsResult!

  # Remove an OrderLine from the Order
  removeOrderLine(orderLineId: ID!): RemoveOrderItemsResult!

  # Remove all OrderLine from the Order
  removeAllOrderLines: RemoveOrderItemsResult!

  # Adjusts an OrderLine. If custom fields are defined on the OrderLine entity, a
  # third argument 'customFields' of type `OrderLineCustomFieldsInput` will be available.
  adjustOrderLine(orderLineId: ID!, quantity: Int!): UpdateOrderItemsResult!

  # Applies the given coupon code to the active Order
  applyCouponCode(couponCode: String!): ApplyCouponCodeResult!

  # Removes the given coupon code from the active Order
  removeCouponCode(couponCode: String!): Order

  # Transitions an Order to a new state. Valid next states can be found by querying `nextOrderStates`
  transitionOrderToState(state: String!): TransitionOrderToStateResult

  # Sets the shipping address for this order
  setOrderShippingAddress(input: CreateAddressInput!): ActiveOrderResult!

  # Sets the billing address for this order
  setOrderBillingAddress(input: CreateAddressInput!): ActiveOrderResult!

  # Allows any custom fields to be set for the active order
  setOrderCustomFields(input: UpdateOrderInput!): ActiveOrderResult!

  # Sets the shipping method by id, which can be obtained with the `eligibleShippingMethods` query
  setOrderShippingMethod(shippingMethodId: ID!): SetOrderShippingMethodResult!

  # Add a Payment to the Order
  addPaymentToOrder(input: PaymentInput!): AddPaymentToOrderResult!

  # Set the Customer for the Order. Required only if the Customer is not currently logged in
  setCustomerForOrder(input: CreateCustomerInput!): SetCustomerForOrderResult!

  # Authenticates the user using the native authentication strategy. This mutation
  # is an alias for `authenticate({ native: { ... }})`
  login(
    username: String!
    password: String!
    rememberMe: Boolean
  ): NativeAuthenticationResult!

  # Authenticates the user using a named authentication strategy
  authenticate(
    input: AuthenticationInput!
    rememberMe: Boolean
  ): AuthenticationResult!

  # End the current authenticated session
  logout: Success!

  # Register a Customer account with the given credentials. There are three possible registration flows:
  #
  # _If `authOptions.requireVerification` is set to `true`:_
  #
  # 1. **The Customer is registered _with_ a password**. A verificationToken will
  # be created (and typically emailed to the Customer). That
  #    verificationToken would then be passed to the `verifyCustomerAccount`
  # mutation _without_ a password. The Customer is then
  #    verified and authenticated in one step.
  # 2. **The Customer is registered _without_ a password**. A verificationToken
  # will be created (and typically emailed to the Customer). That
  #    verificationToken would then be passed to the `verifyCustomerAccount`
  # mutation _with_ the chosed password of the Customer. The Customer is then
  #    verified and authenticated in one step.
  #
  # _If `authOptions.requireVerification` is set to `false`:_
  #
  # 3. The Customer _must_ be registered _with_ a password. No further action is
  # needed - the Customer is able to authenticate immediately.
  registerCustomerAccount(
    input: RegisterCustomerInput!
  ): RegisterCustomerAccountResult!

  # Regenerate and send a verification token for a new Customer registration. Only
  # applicable if `authOptions.requireVerification` is set to true.
  refreshCustomerVerification(
    emailAddress: String!
  ): RefreshCustomerVerificationResult!

  # Update an existing Customer
  updateCustomer(input: UpdateCustomerInput!): Customer!

  # Create a new Customer Address
  createCustomerAddress(input: CreateAddressInput!): Address!

  # Update an existing Address
  updateCustomerAddress(input: UpdateAddressInput!): Address!

  # Delete an existing Address
  deleteCustomerAddress(id: ID!): Success!

  # Verify a Customer email address with the token sent to that address. Only
  # applicable if `authOptions.requireVerification` is set to true.
  #
  # If the Customer was not registered with a password in the `registerCustomerAccount` mutation, the a password _must_ be
  # provided here.
  verifyCustomerAccount(
    token: String!
    password: String
  ): VerifyCustomerAccountResult!

  # Update the password of the active Customer
  updateCustomerPassword(
    currentPassword: String!
    newPassword: String!
  ): UpdateCustomerPasswordResult!

  # Request to update the emailAddress of the active Customer. If `authOptions.requireVerification` is enabled
  # (as is the default), then the `identifierChangeToken` will be assigned to the current User and
  # a IdentifierChangeRequestEvent will be raised. This can then be used e.g. by the EmailPlugin to email
  # that verification token to the Customer, which is then used to verify the change of email address.
  requestUpdateCustomerEmailAddress(
    password: String!
    newEmailAddress: String!
  ): RequestUpdateCustomerEmailAddressResult!

  # Confirm the update of the emailAddress with the provided token, which has been generated by the
  # `requestUpdateCustomerEmailAddress` mutation.
  updateCustomerEmailAddress(token: String!): UpdateCustomerEmailAddressResult!

  # Requests a password reset email to be sent
  requestPasswordReset(emailAddress: String!): RequestPasswordResetResult

  # Resets a Customer's password based on the provided token
  resetPassword(token: String!, password: String!): ResetPasswordResult!
}

union NativeAuthenticationResult =
    CurrentUser
  | InvalidCredentialsError
  | NotVerifiedError
  | NativeAuthStrategyError

input NativeAuthInput {
  username: String!
  password: String!
}

# Retured when attempting an operation that relies on the NativeAuthStrategy, if that strategy is not configured.
type NativeAuthStrategyError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

# Retured when attemting to set a negative OrderLine quantity.
type NegativeQuantityError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

# Returned when invoking a mutation which depends on there being an active Order on the
# current session.
type NoActiveOrderError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

interface Node {
  id: ID!
}

# Returned if `authOptions.requireVerification` is set to `true` (which is the default)
# and an unverified user attempts to authenticate.
type NotVerifiedError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

input NumberOperators {
  eq: Float
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  between: NumberRange
}

input NumberRange {
  start: Float!
  end: Float!
}

type Order implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  # The date & time that the Order was placed, i.e. the Customer
  # completed the checkout and the Order is no longer "active"
  orderPlacedAt: DateTime

  # A unique code for the Order
  code: String!
  state: String!

  # An order is active as long as the payment process has not been completed
  active: Boolean!
  customer: Customer
  shippingAddress: OrderAddress
  billingAddress: OrderAddress
  lines: [OrderLine!]!

  # Surcharges are arbitrary modifications to the Order total which are neither
  # ProductVariants nor discounts resulting from applied Promotions. For example,
  # one-off discounts based on customer interaction, or surcharges based on payment
  # methods.
  surcharges: [Surcharge!]!

  # Order-level adjustments to the order total, such as discounts from promotions
  adjustments: [Adjustment!]! @deprecated(reason: "Use `discounts` instead")
  discounts: [Adjustment!]!

  # An array of all coupon codes applied to the Order
  couponCodes: [String!]!

  # Promotions applied to the order. Only gets populated after the payment process has completed.
  promotions: [Promotion!]!
  payments: [Payment!]
  fulfillments: [Fulfillment!]
  totalQuantity: Int!

  # The subTotal is the total of all OrderLines in the Order. This figure also includes any Order-level
  # discounts which have been prorated (proportionally distributed) amongst the OrderItems.
  # To get a total of all OrderLines which does not account for prorated discounts, use the
  # sum of `OrderLine.discountedLinePrice` values.
  subTotal: Int!

  # Same as subTotal, but inclusive of tax
  subTotalWithTax: Int!
  currencyCode: CurrencyCode!
  shippingLines: [ShippingLine!]!
  shipping: Int!
  shippingWithTax: Int!

  # Equal to subTotal plus shipping
  total: Int!

  # The final payable amount. Equal to subTotalWithTax plus shippingWithTax
  totalWithTax: Int!

  # A summary of the taxes being applied to this Order
  taxSummary: [OrderTaxSummary!]!
  history(options: HistoryEntryListOptions): HistoryEntryList!
  customFields: OrderCustomFields
}

type OrderAddress {
  fullName: String
  company: String
  streetLine1: String
  streetLine2: String
  city: String
  province: String
  postalCode: String
  country: String
  countryCode: String
  phoneNumber: String
  customFields: JSON
}

type OrderCustomFields {
  notes: String
}

input OrderFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  orderPlacedAt: DateOperators
  code: StringOperators
  state: StringOperators
  active: BooleanOperators
  totalQuantity: NumberOperators
  subTotal: NumberOperators
  subTotalWithTax: NumberOperators
  currencyCode: StringOperators
  shipping: NumberOperators
  shippingWithTax: NumberOperators
  total: NumberOperators
  totalWithTax: NumberOperators
  notes: StringOperators
}

type OrderItem implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  cancelled: Boolean!

  # The price of a single unit, excluding tax and discounts
  unitPrice: Int!

  # The price of a single unit, including tax but excluding discounts
  unitPriceWithTax: Int!

  # The price of a single unit including discounts, excluding tax.
  #
  # If Order-level discounts have been applied, this will not be the
  # actual taxable unit price (see `proratedUnitPrice`), but is generally the
  # correct price to display to customers to avoid confusion
  # about the internal handling of distributed Order-level discounts.
  discountedUnitPrice: Int!

  # The price of a single unit including discounts and tax
  discountedUnitPriceWithTax: Int!

  # The actual unit price, taking into account both item discounts _and_ prorated (proportially-distributed)
  # Order-level discounts. This value is the true economic value of the OrderItem, and is used in tax
  # and refund calculations.
  proratedUnitPrice: Int!

  # The proratedUnitPrice including tax
  proratedUnitPriceWithTax: Int!
  unitTax: Int!
  unitPriceIncludesTax: Boolean!
    @deprecated(reason: "`unitPrice` is now always without tax")
  taxRate: Float!
  adjustments: [Adjustment!]!
  taxLines: [TaxLine!]!
  fulfillment: Fulfillment
  refundId: ID
}

# Retured when the maximum order size limit has been reached.
type OrderLimitError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  maxItems: Int!
}

type OrderLine implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  featuredAsset: Asset

  # The price of a single unit, excluding tax and discounts
  unitPrice: Int!

  # The price of a single unit, including tax but excluding discounts
  unitPriceWithTax: Int!

  # Non-zero if the unitPrice has changed since it was initially added to Order
  unitPriceChangeSinceAdded: Int!

  # Non-zero if the unitPriceWithTax has changed since it was initially added to Order
  unitPriceWithTaxChangeSinceAdded: Int!

  # The price of a single unit including discounts, excluding tax.
  #
  # If Order-level discounts have been applied, this will not be the
  # actual taxable unit price (see `proratedUnitPrice`), but is generally the
  # correct price to display to customers to avoid confusion
  # about the internal handling of distributed Order-level discounts.
  discountedUnitPrice: Int!

  # The price of a single unit including discounts and tax
  discountedUnitPriceWithTax: Int!

  # The actual unit price, taking into account both item discounts _and_ prorated (proportially-distributed)
  # Order-level discounts. This value is the true economic value of the OrderItem, and is used in tax
  # and refund calculations.
  proratedUnitPrice: Int!

  # The proratedUnitPrice including tax
  proratedUnitPriceWithTax: Int!
  quantity: Int!
  items: [OrderItem!]!
  totalPrice: Int! @deprecated(reason: "Use `linePriceWithTax` instead")
  taxRate: Float!

  # The total price of the line excluding tax and discounts.
  linePrice: Int!

  # The total price of the line including tax bit excluding discounts.
  linePriceWithTax: Int!

  # The price of the line including discounts, excluding tax
  discountedLinePrice: Int!

  # The price of the line including discounts and tax
  discountedLinePriceWithTax: Int!

  # The actual line price, taking into account both item discounts _and_ prorated (proportially-distributed)
  # Order-level discounts. This value is the true economic value of the OrderLine, and is used in tax
  # and refund calculations.
  proratedLinePrice: Int!

  # The proratedLinePrice including tax
  proratedLinePriceWithTax: Int!

  # The total tax on this line
  lineTax: Int!
  adjustments: [Adjustment!]! @deprecated(reason: "Use `discounts` instead")
  discounts: [Adjustment!]!
  taxLines: [TaxLine!]!
  order: Order!
  customFields: JSON
}

type OrderList implements PaginatedList {
  items: [Order!]!
  totalItems: Int!
}

input OrderListOptions {
  skip: Int
  take: Int
  sort: OrderSortParameter
  filter: OrderFilterParameter
}

# Returned when attempting to modify the contents of an Order that is not in the `AddingItems` state.
type OrderModificationError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

# Returned when attempting to add a Payment to an Order that is not in the `ArrangingPayment` state.
type OrderPaymentStateError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

input OrderSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  orderPlacedAt: SortOrder
  code: SortOrder
  state: SortOrder
  totalQuantity: SortOrder
  subTotal: SortOrder
  subTotalWithTax: SortOrder
  shipping: SortOrder
  shippingWithTax: SortOrder
  total: SortOrder
  totalWithTax: SortOrder
  notes: SortOrder
}

# Returned if there is an error in transitioning the Order state
type OrderStateTransitionError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  transitionError: String!
  fromState: String!
  toState: String!
}

# A summary of the taxes being applied to this order, grouped
# by taxRate.
type OrderTaxSummary {
  # A description of this tax
  description: String!

  # The taxRate as a percentage
  taxRate: Float!

  # The total net price or OrderItems to which this taxRate applies
  taxBase: Int!

  # The total tax being applied to the Order at this taxRate
  taxTotal: Int!
}

interface PaginatedList {
  items: [Node!]!
  totalItems: Int!
}

# Retured when attemting to verify a customer account with a password, when a password has already been set.
type PasswordAlreadySetError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

# Retured if the token used to reset a Customer's password is valid, but has
# expired according to the `verificationTokenDuration` setting in the AuthOptions.
type PasswordResetTokenExpiredError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

# Retured if the token used to reset a Customer's password is either
# invalid or does not match any expected tokens.
type PasswordResetTokenInvalidError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

type Payment implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  method: String!
  amount: Int!
  state: String!
  transactionId: String
  errorMessage: String
  refunds: [Refund!]!
  metadata: JSON
}

# Returned when a Payment is declined by the payment provider.
type PaymentDeclinedError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  paymentErrorMessage: String!
}

# Returned when a Payment fails due to an error.
type PaymentFailedError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
  paymentErrorMessage: String!
}

# Passed as input to the `addPaymentToOrder` mutation.
input PaymentInput {
  # This field should correspond to the `code` property of a PaymentMethodHandler.
  method: String!

  # This field should contain arbitrary data passed to the specified PaymentMethodHandler's `createPayment()` method
  # as the "metadata" argument. For example, it could contain an ID for the payment and other
  # data generated by the payment provider.
  metadata: JSON!
}

type PaymentMethodQuote {
  id: ID!
  code: String!
  isEligible: Boolean!
  eligibilityMessage: String
}

# @description
# Permissions for administrators and customers. Used to control access to
# GraphQL resolvers via the {@link Allow} decorator.
#
# @docsCategory common
enum Permission {
  # Authenticated means simply that the user is logged in
  Authenticated

  # SuperAdmin has unrestricted access to all operations
  SuperAdmin

  # Owner means the user owns this entity, e.g. a Customer's own Order
  Owner

  # Public means any unauthenticated user may perform the operation
  Public

  # Grants permission to create Catalog
  CreateCatalog

  # Grants permission to read Catalog
  ReadCatalog

  # Grants permission to update Catalog
  UpdateCatalog

  # Grants permission to delete Catalog
  DeleteCatalog

  # Grants permission to create Customer
  CreateCustomer

  # Grants permission to read Customer
  ReadCustomer

  # Grants permission to update Customer
  UpdateCustomer

  # Grants permission to delete Customer
  DeleteCustomer

  # Grants permission to create Administrator
  CreateAdministrator

  # Grants permission to read Administrator
  ReadAdministrator

  # Grants permission to update Administrator
  UpdateAdministrator

  # Grants permission to delete Administrator
  DeleteAdministrator

  # Grants permission to create Order
  CreateOrder

  # Grants permission to read Order
  ReadOrder

  # Grants permission to update Order
  UpdateOrder

  # Grants permission to delete Order
  DeleteOrder

  # Grants permission to create Promotion
  CreatePromotion

  # Grants permission to read Promotion
  ReadPromotion

  # Grants permission to update Promotion
  UpdatePromotion

  # Grants permission to delete Promotion
  DeletePromotion

  # Grants permission to create Settings
  CreateSettings

  # Grants permission to read Settings
  ReadSettings

  # Grants permission to update Settings
  UpdateSettings

  # Grants permission to delete Settings
  DeleteSettings
}

# The price range where the result has more than one price
type PriceRange {
  min: Int!
  max: Int!
}

type PriceRangeBucket {
  to: Int!
  count: Int!
}

input PriceRangeInput {
  min: Int!
  max: Int!
}

type Product implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
  featuredAsset: Asset
  assets: [Asset!]!
  variants: [ProductVariant!]!
  optionGroups: [ProductOptionGroup!]!
  facetValues: [FacetValue!]!
  translations: [ProductTranslation!]!
  collections: [Collection!]!
  recommendations: [ProductRecommendation!]!
  resellerDiscount: Int!
  customFields: ProductCustomFields
}

type ProductCustomFields {
  productRecommendationsEnabled: Boolean
  groupKey: String
}

input ProductFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  slug: StringOperators
  description: StringOperators
  resellerDiscount: NumberOperators
  productRecommendationsEnabled: BooleanOperators
  groupKey: StringOperators
}

type ProductList implements PaginatedList {
  items: [Product!]!
  totalItems: Int!
}

input ProductListOptions {
  skip: Int
  take: Int
  sort: ProductSortParameter
  filter: ProductFilterParameter
}

type ProductOption implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  groupId: ID!
  group: ProductOptionGroup!
  translations: [ProductOptionTranslation!]!
  customFields: JSON
}

type ProductOptionGroup implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  options: [ProductOption!]!
  translations: [ProductOptionGroupTranslation!]!
  customFields: JSON
}

type ProductOptionGroupTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type ProductOptionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type ProductRecommendation {
  product: Product!
  recommendation: Product!
  type: RecommendationType!
}

input ProductSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  slug: SortOrder
  description: SortOrder
  resellerDiscount: SortOrder
  productRecommendationsEnabled: SortOrder
  groupKey: SortOrder
}

type ProductTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
}

type ProductVariant implements Node {
  id: ID!
  product: Product!
  productId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  sku: String!
  name: String!
  featuredAsset: Asset
  assets: [Asset!]!
  price: Int!
  currencyCode: CurrencyCode!
  priceIncludesTax: Boolean!
    @deprecated(reason: "price now always excludes tax")
  priceWithTax: Int!
  stockLevel: String!
  taxRateApplied: TaxRate!
  taxCategory: TaxCategory!
  options: [ProductOption!]!
  facetValues: [FacetValue!]!
  translations: [ProductVariantTranslation!]!
  bulkDiscounts: [BulkDiscount!]!
  resellerDiscount: Int!
  customFields: ProductVariantCustomFields
}

type ProductVariantCustomFields {
  bulkDiscountEnabled: Boolean
  minimumOrderQuantity: Int
}

input ProductVariantFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  sku: StringOperators
  name: StringOperators
  price: NumberOperators
  currencyCode: StringOperators
  priceIncludesTax: BooleanOperators
  priceWithTax: NumberOperators
  stockLevel: StringOperators
  resellerDiscount: NumberOperators
  bulkDiscountEnabled: BooleanOperators
  minimumOrderQuantity: NumberOperators
}

type ProductVariantList implements PaginatedList {
  items: [ProductVariant!]!
  totalItems: Int!
}

input ProductVariantListOptions {
  skip: Int
  take: Int
  sort: ProductVariantSortParameter
  filter: ProductVariantFilterParameter
}

input ProductVariantSortParameter {
  id: SortOrder
  productId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  sku: SortOrder
  name: SortOrder
  price: SortOrder
  priceWithTax: SortOrder
  stockLevel: SortOrder
  resellerDiscount: SortOrder
  bulkDiscountEnabled: SortOrder
  minimumOrderQuantity: SortOrder
}

type ProductVariantTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type Promotion implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  startsAt: DateTime
  endsAt: DateTime
  couponCode: String
  perCustomerUsageLimit: Int
  name: String!
  enabled: Boolean!
  conditions: [ConfigurableOperation!]!
  actions: [ConfigurableOperation!]!
}

type PromotionList implements PaginatedList {
  items: [Promotion!]!
  totalItems: Int!
}

type Query {
  # The active Channel
  activeChannel: Channel!

  # The active Customer
  activeCustomer: Customer

  # The active Order. Will be `null` until an Order is created via `addItemToOrder`. Once an Order reaches the
  # state of `PaymentApproved` or `PaymentSettled`, then that Order is no longer considered "active" and this
  # query will once again return `null`.
  activeOrder: Order

  # An array of supported Countries
  availableCountries: [Country!]!

  # A list of Collections available to the shop
  collections(options: CollectionListOptions): CollectionList!

  # Returns a Collection either by its id or slug. If neither 'id' nor 'slug' is speicified, an error will result.
  collection(id: ID, slug: String): Collection

  # Returns a list of eligible shipping methods based on the current active Order
  eligibleShippingMethods: [ShippingMethodQuote!]!

  # Returns a list of payment methods and their eligibility based on the current active Order
  eligiblePaymentMethods: [PaymentMethodQuote!]!

  # Returns information about the current authenticated User
  me: CurrentUser

  # Returns the possible next states that the activeOrder can transition to
  nextOrderStates: [String!]!

  # Returns an Order based on the id. Note that in the Shop API, only orders belonging to the
  # currently-authenticated User may be queried.
  order(id: ID!): Order

  # Returns an Order based on the order `code`. For guest Orders (i.e. Orders placed by non-authenticated Customers)
  # this query will only return the Order within 2 hours of the Order being placed. This allows an Order confirmation
  # screen to be shown immediately after completion of a guest checkout, yet prevents security risks of allowing
  # general anonymous access to Order data.
  orderByCode(code: String!): Order

  # Get a Product either by id or slug. If neither 'id' nor 'slug' is speicified, an error will result.
  product(id: ID, slug: String): Product

  # Get a list of Products
  products(options: ProductListOptions): ProductList!

  # Search Products based on the criteria set by the `SearchInput`
  search(input: SearchInput!): SearchResponse!
  productRecommendations(productId: ID!): [ProductRecommendation!]!
  productBulkDiscounts(productId: ID!): [BulkDiscount!]!
  productBySlug(slug: String!): Product
}

enum RecommendationType {
  CROSSSELL
  UPSELL
}

union RefreshCustomerVerificationResult = Success | NativeAuthStrategyError

type Refund implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  items: Int!
  shipping: Int!
  adjustment: Int!
  total: Int!
  method: String
  state: String!
  transactionId: String
  reason: String
  orderItems: [OrderItem!]!
  paymentId: ID!
  metadata: JSON
}

union RegisterCustomerAccountResult =
    Success
  | MissingPasswordError
  | NativeAuthStrategyError

input RegisterCustomerInput {
  emailAddress: String!
  title: String
  firstName: String
  lastName: String
  phoneNumber: String
  password: String
}

type RelationCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  entity: String!
  scalarFields: [String!]!
}

union RemoveOrderItemsResult = Order | OrderModificationError

union RequestPasswordResetResult = Success | NativeAuthStrategyError

union RequestUpdateCustomerEmailAddressResult =
    Success
  | InvalidCredentialsError
  | EmailAddressConflictError
  | NativeAuthStrategyError

type ResellerDiscount {
  facetValueIds: [ID!]!
  discount: Int!
}

union ResetPasswordResult =
    CurrentUser
  | PasswordResetTokenInvalidError
  | PasswordResetTokenExpiredError
  | NativeAuthStrategyError

type Role implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  description: String!
  permissions: [Permission!]!
  channels: [Channel!]!
}

type RoleList implements PaginatedList {
  items: [Role!]!
  totalItems: Int!
}

input SearchInput {
  term: String
  facetValueIds: [ID!]
  facetValueOperator: LogicalOperator
  collectionId: ID
  collectionSlug: String
  groupByProduct: Boolean
  take: Int
  skip: Int
  sort: SearchResultSortParameter
  priceRange: PriceRangeInput
  priceRangeWithTax: PriceRangeInput
}

type SearchReindexResponse {
  success: Boolean!
}

type SearchResponse {
  items: [SearchResult!]!
  totalItems: Int!
  facetValues: [FacetValueResult!]!
  prices: SearchResponsePriceData!
}

type SearchResponsePriceData {
  range: PriceRange!
  rangeWithTax: PriceRange!
  buckets: [PriceRangeBucket!]!
  bucketsWithTax: [PriceRangeBucket!]!
}

type SearchResult {
  sku: String!
  slug: String!
  productId: ID!
  productName: String!
  productPreview: String!
    @deprecated(reason: "Use `productAsset.preview` instead")
  productAsset: SearchResultAsset
  productVariantId: ID!
  productVariantName: String!
  productVariantPreview: String!
    @deprecated(reason: "Use `productVariantAsset.preview` instead")
  productVariantAsset: SearchResultAsset
  price: SearchResultPrice!
  priceWithTax: SearchResultPrice!
  currencyCode: CurrencyCode!
  description: String!
  facetIds: [ID!]!
  facetValueIds: [ID!]!

  # An array of ids of the Collections in which this result appears
  collectionIds: [ID!]!

  # A relevence score for the result. Differs between database implementations
  score: Float!
}

type SearchResultAsset {
  id: ID!
  preview: String!
  focalPoint: Coordinate
}

# The price of a search result product, either as a range or as a single price
union SearchResultPrice = PriceRange | SinglePrice

input SearchResultSortParameter {
  name: SortOrder
  price: SortOrder
}

union SetCustomerForOrderResult =
    Order
  | AlreadyLoggedInError
  | EmailAddressConflictError
  | NoActiveOrderError

union SetOrderShippingMethodResult =
    Order
  | OrderModificationError
  | IneligibleShippingMethodError
  | NoActiveOrderError

type ShippingLine {
  shippingMethod: ShippingMethod!
  price: Int!
  priceWithTax: Int!
  discountedPrice: Int!
  discountedPriceWithTax: Int!
  discounts: [Adjustment!]!
}

type ShippingMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  name: String!
  description: String!
  fulfillmentHandlerCode: String!
  checker: ConfigurableOperation!
  calculator: ConfigurableOperation!
  translations: [ShippingMethodTranslation!]!
  customFields: JSON
}

type ShippingMethodList implements PaginatedList {
  items: [ShippingMethod!]!
  totalItems: Int!
}

type ShippingMethodQuote {
  id: ID!
  price: Int!
  priceWithTax: Int!
  name: String!
  description: String!

  # Any optional metadata returned by the ShippingCalculator in the ShippingCalculationResult
  metadata: JSON
}

type ShippingMethodTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  description: String!
}

# The price value where the result has a single price
type SinglePrice {
  value: Int!
}

enum SortOrder {
  ASC
  DESC
}

type StringCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  length: Int
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  pattern: String
  options: [StringFieldOption!]
}

type StringFieldOption {
  value: String!
  label: [LocalizedString!]
}

input StringOperators {
  eq: String
  notEq: String
  contains: String
  notContains: String
  in: [String!]
  notIn: [String!]
  regex: String
}

# Indicates that an operation succeeded, where we do not want to return any more specific information.
type Success {
  success: Boolean!
}

type Surcharge implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  sku: String
  taxLines: [TaxLine!]!
  price: Int!
  priceWithTax: Int!
  taxRate: Float!
}

type Tag implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  value: String!
}

type TagList implements PaginatedList {
  items: [Tag!]!
  totalItems: Int!
}

type TaxCategory implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  isDefault: Boolean!
}

type TaxLine {
  description: String!
  taxRate: Float!
}

type TaxRate implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  enabled: Boolean!
  value: Float!
  category: TaxCategory!
  zone: Zone!
  customerGroup: CustomerGroup
}

type TaxRateList implements PaginatedList {
  items: [TaxRate!]!
  totalItems: Int!
}

union TransitionOrderToStateResult = Order | OrderStateTransitionError

input UpdateAddressInput {
  id: ID!
  fullName: String
  company: String
  streetLine1: String
  streetLine2: String
  city: String
  province: String
  postalCode: String
  countryCode: String
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: JSON
}

union UpdateCustomerEmailAddressResult =
    Success
  | IdentifierChangeTokenInvalidError
  | IdentifierChangeTokenExpiredError
  | NativeAuthStrategyError

input UpdateCustomerInput {
  title: String
  firstName: String
  lastName: String
  phoneNumber: String
  customFields: JSON
}

union UpdateCustomerPasswordResult =
    Success
  | InvalidCredentialsError
  | NativeAuthStrategyError

input UpdateOrderCustomFieldsInput {
  notes: String
}

input UpdateOrderInput {
  customFields: UpdateOrderCustomFieldsInput
}

union UpdateOrderItemsResult =
    Order
  | OrderModificationError
  | OrderLimitError
  | NegativeQuantityError
  | InsufficientStockError

# The `Upload` scalar type represents a file upload.
scalar Upload

type User implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  identifier: String!
  verified: Boolean!
  roles: [Role!]!
  lastLogin: DateTime
  authenticationMethods: [AuthenticationMethod!]!
  customFields: JSON
}

# Returned if the verification token (used to verify a Customer's email address) is valid, but has
# expired according to the `verificationTokenDuration` setting in the AuthOptions.
type VerificationTokenExpiredError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

# Retured if the verification token (used to verify a Customer's email address) is either
# invalid or does not match any expected tokens.
type VerificationTokenInvalidError implements ErrorResult {
  errorCode: ErrorCode!
  message: String!
}

union VerifyCustomerAccountResult =
    CurrentUser
  | VerificationTokenInvalidError
  | VerificationTokenExpiredError
  | MissingPasswordError
  | PasswordAlreadySetError
  | NativeAuthStrategyError

type Zone implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  members: [Country!]!
}
